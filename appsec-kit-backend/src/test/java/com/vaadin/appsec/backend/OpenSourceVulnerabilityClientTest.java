/*-
 * Copyright (C) 2023 Vaadin Ltd
 *
 * This program is available under Vaadin Commercial License and Service Terms.
 *
 *
 * See <https://vaadin.com/commercial-license-and-service-terms> for the full license.
 */
package com.vaadin.appsec.backend;

import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.Test;
import org.mockito.MockedConstruction;

import com.vaadin.appsec.backend.model.osv.request.QueryBatchRequestPayload;
import com.vaadin.appsec.backend.model.osv.response.OpenSourceVulnerability;
import com.vaadin.appsec.backend.model.osv.response.QueryBatchResponse;
import com.vaadin.appsec.backend.model.osv.response.VulnerabilityIdArray;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockConstruction;
import static org.mockito.Mockito.when;

public class OpenSourceVulnerabilityClientTest {

    static class TestOpenSourceVulnerabilityClient
            extends OpenSourceVulnerabilityClient {

        TestOpenSourceVulnerabilityClient(int ratePerSecond) {
            super(ratePerSecond);
        }

        @Override
        HttpURLConnection createHttpURLConnection(String urlStr,
                String requestMethod) {
            HttpURLConnection connection = mock(HttpURLConnection.class);
            InputStream inputStream = mock(InputStream.class);
            try {
                when(connection.getInputStream()).thenReturn(inputStream);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            return connection;
        }
    }

    @Test
    public void queryBatch_returnsQueryBatchResponse() throws IOException {
        try (MockedConstruction<ObjectMapper> mockedObjectMapper = mockConstruction(
                ObjectMapper.class)) {
            TestOpenSourceVulnerabilityClient osvClient = new TestOpenSourceVulnerabilityClient(
                    5);

            when(mockedObjectMapper.constructed().get(0)
                    .readValue(any(InputStream.class), any(Class.class)))
                            .thenReturn(createQueryBatchResponse());

            QueryBatchResponse response = osvClient
                    .queryBatch(new QueryBatchRequestPayload());

            assertEquals(2, response.getResults().length);
        }
    }

    @Test
    public void queryVulnerability_returnsOpenSourceVulnerability()
            throws IOException {
        try (MockedConstruction<ObjectMapper> mockedObjectMapper = mockConstruction(
                ObjectMapper.class)) {
            TestOpenSourceVulnerabilityClient osvClient = new TestOpenSourceVulnerabilityClient(
                    5);

            when(mockedObjectMapper.constructed().get(0)
                    .readValue(any(InputStream.class), any(Class.class)))
                            .thenReturn(createOpenSourceVulnerability());

            OpenSourceVulnerability vuln = osvClient
                    .queryVulnerability("CVE-1");

            assertEquals("1", vuln.getId());
        }
    }

    private QueryBatchResponse createQueryBatchResponse() {
        QueryBatchResponse response = new QueryBatchResponse();
        VulnerabilityIdArray vulnArray1 = new VulnerabilityIdArray();
        VulnerabilityIdArray vulnArray2 = new VulnerabilityIdArray();
        response.setResults(
                new VulnerabilityIdArray[] { vulnArray1, vulnArray2 });
        return response;
    }

    private OpenSourceVulnerability createOpenSourceVulnerability() {
        OpenSourceVulnerability osvVuln = new OpenSourceVulnerability();
        osvVuln.setId("1");
        return osvVuln;
    }
}
