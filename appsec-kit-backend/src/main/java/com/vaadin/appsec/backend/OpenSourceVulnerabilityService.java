/*-
 * Copyright (C) 2023 Vaadin Ltd
 *
 * This program is available under Vaadin Commercial License and Service Terms.
 *
 *
 * See <https://vaadin.com/commercial-license-and-service-terms> for the full license.
 */

package com.vaadin.appsec.backend;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

import org.cyclonedx.model.Component;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vaadin.appsec.backend.model.osv.request.QueryBatchRequestPayload;
import com.vaadin.appsec.backend.model.osv.request.QueryRequestPayload;
import com.vaadin.appsec.backend.model.osv.response.Ecosystem;
import com.vaadin.appsec.backend.model.osv.response.OpenSourceVulnerability;
import com.vaadin.appsec.backend.model.osv.response.Package;
import com.vaadin.appsec.backend.model.osv.response.QueryBatchResponse;
import com.vaadin.appsec.backend.model.osv.response.VulnerabilityId;

/**
 * Service for fetching and processing vulnerabilities using
 * {@link OpenSourceVulnerabilityClient}
 */
class OpenSourceVulnerabilityService {

    private static final Logger LOGGER = LoggerFactory
            .getLogger(OpenSourceVulnerabilityService.class);

    private static final int COMPONENT_BATCH_SIZE = 1000;

    private final OpenSourceVulnerabilityClient osvClient;
    private final RateLimiter rateLimiter;

    OpenSourceVulnerabilityService(int ratePerSecond) {
        osvClient = new OpenSourceVulnerabilityClient();
        rateLimiter = new RateLimiter(ratePerSecond);
    }

    /**
     * Returns fetched vulnerabilities for given list of Bom components
     *
     * @param components
     *            the list of BOM components
     * @return the list of vulnerabilities
     */
    List<OpenSourceVulnerability> getVulnerabilities(
            List<Component> components) {
        List<OpenSourceVulnerability> vulnerabilities = new ArrayList<>();
        List<String> vulnerabilityIds = getVulnerabilityIds(components);

        vulnerabilityIds.forEach(id -> {
            try {
                rateLimiter.acquire();
            } catch (InterruptedException e) {
                throw new AppSecException(
                        "OpenSourceVulnerabilityClient rate limiter interrupted when getting vulnerabilities",
                        e);
            }
            Optional<OpenSourceVulnerability> vulnerability = osvClient
                    .queryVulnerability(id);
            vulnerability.ifPresent(vulnerabilities::add);
        });
        LOGGER.debug("Vulnerabilities from OSV service " + vulnerabilities);

        return vulnerabilities;
    }

    private List<String> getVulnerabilityIds(List<Component> components) {
        final List<String> vulnerabilityIds = new ArrayList<>();
        List<List<Component>> batchComponents = batchComponents(components);

        batchComponents.forEach(componentList -> {
            try {
                rateLimiter.acquire();
            } catch (InterruptedException e) {
                throw new AppSecException(
                        "OpenSourceVulnerabilityClient rate limiter interrupted when getting vulnerability ids",
                        e);
            }
            QueryBatchRequestPayload payload = createQueryBatchRequestPayload(
                    componentList);
            Optional<QueryBatchResponse> batchResponse = osvClient
                    .queryBatch(payload);

            batchResponse.ifPresent(response -> vulnerabilityIds.addAll(Arrays
                    .stream(response.getResults())
                    .filter(vulnerabilityIdArray -> vulnerabilityIdArray
                            .getVulnerabilityIds() != null)
                    .flatMap(vulnerabilityIdArray -> Arrays
                            .stream(vulnerabilityIdArray.getVulnerabilityIds())
                            .filter(Objects::nonNull))
                    .map(VulnerabilityId::getId).collect(Collectors.toList())));
        });

        return vulnerabilityIds;
    }

    private List<List<Component>> batchComponents(List<Component> components) {
        List<List<Component>> batches = new ArrayList<>();
        for (int i = 0; i < components.size(); i += COMPONENT_BATCH_SIZE) {
            batches.add(components.subList(i,
                    Math.min(i + COMPONENT_BATCH_SIZE, components.size())));
        }
        return batches;
    }

    private QueryBatchRequestPayload createQueryBatchRequestPayload(
            List<Component> components) {
        return new QueryBatchRequestPayload(
                components.stream().map(this::createQueryRequestPayload)
                        .toArray(QueryRequestPayload[]::new));
    }

    private QueryRequestPayload createQueryRequestPayload(Component component) {
        return new QueryRequestPayload(component.getVersion(),
                createPackage(component));
    }

    private Package createPackage(Component component) {
        return new Package(Ecosystem.MAVEN.value(),
                component.getGroup().concat(":").concat(component.getName()));
    }
}
